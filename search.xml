<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[读《selenium2自动化测试实战--基于python语言》]]></title>
    <url>%2F2018%2F05%2F02%2F2018-05-02-selenium2-auto-test-base-on-python%2F</url>
    <content type="text"><![CDATA[1.1 软件测试分类1.根据项目流程阶段划分软件测试 单元测试：单元测试（或模块测试）是对程序中的单个子程序或具有独立功能的代码进行测试的过程。 集成测试：集成测试是在单元测试的基础上，先通过单元模块组成系统或子系统，再进行测试。重点是检查模块之间的借口是否正确。 系统测试：系统测试是针对整个产品系统进行的测试，验证系统是否满足需求规格的定义，以及软件系统的正确性和性能等是否满足其需求规格的要求。 验收测试：验收测试是部署软件之前的最后一个测试阶段。验收测试的目的是确保软件准备就绪，向软件购买者展示该软件系统能够满足用户的需求。 2.白盒测试、黑盒测试、灰盒测试(主要是根据软件测试工作中对软件代码的可见程度进行划分) 黑盒测试指的是把被测的软件看作一个黑盒子，我们不去关心盒子里面的结构是什么样子的，只关心软件的输入数据和输出结果。 它只检查程序呈现给用户的功能是否按照需求规格说明书的规定正常使用、程序是否能接收输入数据并产生正确的输出信息。黑盒测试着眼于程序外部结构，不考虑内部逻辑结构，主要针对软件界面和软件功能进行测试。 白盒测试，指的是把盒子打开，去研究里面的源代码和程序执行结果。 它是按照程序的内部的结构测试程序，通过测试来检测产品内部动作是否按照设计规格说明书的规定正常进行，检验程序中的每条逻辑路径是否都能够按预定要求正确工作。 灰盒测试，介于黑盒测试和白盒测试之间。 3.功能测试与性能测试 功能测试，功能测试主要检查实际功能是否符合用户的需求。功能测试又可以分为很多种：逻辑功能测试、界面测试、易用性测试、安装测试、兼容性测试等 性能测试，是通过自动化的测试工具模拟多种正常、峰值以及异常负载条件对系统的各项性能指标进行的测试。主要包括时间性能和空间性能。 4.手工测试和自动化测试 手工测试就是由测试人员一个一个地去执行测试用例，通过键盘鼠标等输入一些参数，并查看返回结果是否符合预期结果。 自动化测试是把以人为驱动的测试行为转化为机器执行的一种过程。又分为功能性自动化测试和性能自动化测试。 5.冒烟测试、回归测试、随机测试、探索性测试和安全测试 冒烟测试，是指对一个新版本进行大规模的系统测试之前，先验证一下软件的基本功能是否实现，是否具备可测性。 回归测试是指修改了旧代码之后，重新进行测试以确认修改后没有引入新的错误或导致其他代码产生错误。 随机测试，是指测试中的所有输入数据都是随机生成的，其目的是模拟用户的真实操作，并发现一些边缘性的错误。 探索性测试，是一种测试思维技术。强调在碰到问题时及时改变测试策略。 安全测试，是在IT软件产品的生命周期中，特别是产品开发基本完成至发布阶段，对产品进行检验以验证产品符合安全需求定义和产品质量标准的过程。 1.2 分层的自动化测试 单元自动化测试 接口自动化测试 UI自动化测试 1.3 什么样的项目适合自动化测试 任务测试明确，不会明确变动 每日构建后的测试验证 比较频繁的回归测试 软件系统界面稳定，变动少 需要在多平台上运行的相同测试案例、组合遍历型的测试，大量的重复任务 软件维护周期长 项目进度压力不太大 被测软件系统开发较为规范，能够保证系统的可测试性 具备大量的自动化测试平台 测试人员具备较强的编程能力 并非以上10个条件都满足才能进行自动化测试，一般只需满足一下三个条件就可以对其进行自动化测试： 软件需求变动不频繁 项目周期较长 自动化测试脚本可重复使用1.4 自动化测试及工具简介自动化测试的概念有广义和狭义之分：广义上来讲，所有借助工具来辅助进行软件测试的方式都可以称为自动化测试；狭义上来讲，主要是指基于UI蹭的功能自动化测试。常见的自动化测试工具有： UFT(Unified Functional Testing)—最主流 Robot Framework（基于python，强大） Watir（Web Application Testing in Ruby） Selenium（多平台，广泛应用）1.5 selenium工具介绍1.什么是selenium？ selenium主要用于web应用程序的自动化测试，但并不局限于此，它还支持所有基于web的管理任务自动化。 selenium的特点如下： 开源，免费； 多浏览器支持：Firefox，Chrome，IE,Opera，Edge； 多平台支持：Linux，Windows，MAC； 多语言支持：Java，python，Ruby，C#，JavaScript，C++； 对web页面有良好的支持； 简单（API简单）、灵活（用于开发语言驱动）； 支持分布式测试用例执行。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>软件测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《手机摄影从入门到精通》]]></title>
    <url>%2F2018%2F04%2F29%2F2018-04-29-mobile-phone-photo%2F</url>
    <content type="text"><![CDATA[摄影的本质就是记录影像，凝固瞬间，表达作者的意图、思想和情感。 常见问题及解决方法 拍得虚——轻按稳拿对焦 拍得黑——增加曝光补偿开启闪光灯模式 拍得歪——开启辅助线辅助构图 颜色淡——使用手机滤镜 背景乱——用变焦解决 会偏色——调整手机白平衡 注意事项（道法自然） 作者意图（表达的东西） 角度 光线 构图 技术 后期 少即是多 简即是真 构图九套路 横屏竖要直 斜就斜到底 重点就要吸引人（黄金分割法、三分法） 妙在画框中（妙用主题周围环境） 线条吸引眼球 空就空大点 挤就挤满点 稳定才是硬道理 两边拍一样 APP推荐 海报（POCO、Phoster、PicsStudio、TextCutiePro、Piclab） 明信片（留白、美卡） 局部色彩特效（Color Splash、色彩大师、AfterFocus） 画面背景虚化（Afterfocus、LiveDOF、Layrs） 营造不一样的画面效果（Camera 360、VSCOcam、Instagram、snapseed、Mix滤镜大师） 加文字（黄油相机、Phonto、over、nice） 给人加修饰、涂鸦（LINE Camera、Line Brush、SigNote） 画一个搞笑的妆（美图贴贴、百变魔图、美图秀秀、玩图、创意相机、搞笑相机、天天P图） 美女修成记（美颜相机、Fotor、Photo Makeover、Perfect 365、美图秀秀） 制造有味道的素描照片（素描大师、XnSketch、相机360、PowerCam、CmoioBookCamera） 画中画（画中画、玩图、百变魔图、POCO美人相机） 把美丽的风景画成油画（PhotoViva、Brushstroke、转手绘、彩漫相机、魔漫相机） 典型画面既视感（手机APP、织图、FUGUIFILM） 美食美色（食色、美食相机、食日谈、Moldiv）]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>实用技巧，求知</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《从菜鸟到测试架构师：一个测试工程师的成长日记》]]></title>
    <url>%2F2018%2F04%2F25%2F2018-04-25-software-test-zero2one%2F</url>
    <content type="text"><![CDATA[如何确保软件质量、减少质量问题给企业及用户带来的隐患，是软件测试工作的核心。 在大型软件开发团队中，测试被分成很多种类和步骤，每种测试有针对性地模拟使用测试对象的场景，并试图找出测试对象的潜在问题和缺陷(Bug)。在确定原因后，制定严谨完善的解决方案并根据方案修复缺陷。 测试其实是发现并解决问题的过程，而其目标则是让软件产品以尽可能高的质量交付给客户，使软件产品中存在的问题尽可能少。 除了小型项目，进行完全（各种输入和前提条件的组合）的测试是不可行的。可行的方法是运用风险分析和不同系统功能的测试优先级，来确定测试的关注点，从而替代穷尽测试。 单元测试，是和开发最接近的一种测试。开发人员编写单元测试用例并执行，验证单元模块是否得出预期的结果。测试驱动开发（Test Driven Development，TDD）。测试驱动开发的核心就是把单元测试做好，功能开发以通过相应的单元测试用例为目标。单元测试是粒度最小的软件测试，小粒度能保证复杂系统中的每个“螺丝钉”都质量合格。 功能测试是通过黑盒子模式发现代码集成后存在的功能问题的测试。关注的重点是系统的功能。通过执行自动或手动的测试用例，可以验证相应的功能点是否正确。单元测试关注的是一个最小的代码片段(比如一个类或接口）,功能测试关注的是一个完整的业务功能。 性能测试是重点验证软件的非功能性需求的测试。企业级软件通常用于应对复杂苛刻的用户场景。在软件设计和安装的过程中，有许多细节能提供软件的性能，包括吞吐率、稳定性、可靠性等。性能测试通过自动化的方法模拟真实用户并发访问的场景，以验证系统的性能指标或发现其性能瓶颈。 苦练基本功：了解开发平台和方式–操作系统（Windows、Unix、Linux）、搭建测试环境（执行构建测试–使用构建化的脚本、自动化安装） 正确的流程和步骤一定要及时记录。有了流程和步骤的指引，可以避免大量不必要的重复劳动。 中间件（Middleware）是提供系统软件和应用软件之间连接的软件。 敏捷开发（Agile Development）。迭代开发（Iterative Development）和增量开发（Incremental Development）。 迭代开发是一种“重复时序安排”的开发方式。迭代开发把一个完整的瀑布模型开发流程分成多个迭代，每个迭代可以看成是独立的开发过程，其中包含了项目的主要步骤，如设计、开发和测试等。把完整过程分成多个持续时间较短的迭代，其好处是生产的周期变短了，每个完整的周期都会产出相应的产品，这种方式有利于在完整项目开发的过程中跟踪和控制开发进度及产品质量。 增量开发用的则是一种“分段完成”的策略。在增量开发模式中，系统中不同的部分被安排在多个阶段完成，各个部分完成后再集成到系统中。 瀑布开发模型：在开发过程中，整个系统的开发被划分成需求分析、设计实现、测试、集成和维护等阶段。这种划分本质上是把不同性质的项目内容分割到不同的阶段，而某个阶段则专注地进行某种任务。专注在许多情况下带来了高质量，单一流程的划分很容易带来资源浪费和失败风险的增加。如果在某一阶段，项目组只完成一组相同性质的任务，那么，团队中其他无关人员在这段时间里就无事可做了。项目的成果必须到最后阶段才能完成，中间任何步骤出现差错都有可能导致项目全盘失败，这样的项目开发风险很高。 计划和流程–计划定义的是做什么（What）和什么时候做（When），项目执行完全根据计划实施，好的计划是项目成功的基础；流程是项目成功的保障，它定义了怎么做（How），按照标准流程做极其重要，可以避免许多不必要的问题。 培养专业技能：开发技能是基础（数据结构、算法设计、设计模式和体系结构，了解不同的开发语言和平台的差异），开发技能不仅包括设计和实现功能的技术，还包括发布和部署代码、配置环境的技术。 白盒测试指测试人员可以直接访问内部数据结果、算法及其代码实现的测试。常见的方法包括编程应用接口测试（常用）、代码覆盖率测试（检验代码是否满足指定覆盖率的测试）、缺陷注入方法（错误以及临界条件下）等。白盒测试用最直接的方式，从根源上发现程序的缺陷，但是要求测试人员对实现细节比较了解并设计出有效的测试用例，这几乎是不可能的任务。 黑盒测试通过触发业务相关的功能点，检验集成条件下系统的正确性。但是进行黑盒测试的时候系统是集成的，在发现问题后需要打开“黑盒子”，用额外的工作定位问题的确切原因。tips：白盒测试虽然比较复杂，但是能够精准定位出错误点。黑盒测试虽然简单但是只能知道有问题，但是不知道问题出在哪个地方，需要额外时间去定位问题。所以说老天是公平的，鱼与熊掌不可兼得。 手工操作的测试方法，自动化测试方法。回归测试：除了需要测试新发布的内容，还必须验证已经存在的功能是否正确，存在的问题是否已经修复。这有进行回归测试才能保证所有功能在最新版本中的正确性。 软件质量包括两个相关但截然不同的概念——功能性质量（Functional Quality）和结构性质量（Structural Quality）。功能性质量反映的是软件是否按照设计实现并满足相应功能性需求（Functional Requirements）；结构性质量反映的是软件是否满足相关的非功能性需求（Non-Functional Requirements，NFR）。 测试就是获得量化指标的数值，主要有正确性（Correctness）、可靠性（Reliability）、易用性（Usability）、可移植性（Portability）、可迁移性（Migratability）、效率（Efficiency）、可维护性（Maintainability）、可扩展性（Scalability）、健壮性（Robustness）、安全性（Security） 测试驱动开发的要点是先写测试程序，然后再编码实现使其通过测试。测试可以有效推动需求的实现。测试的目标是发现软件中存在的缺陷。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>软件测试</tag>
        <tag>IT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《不要因为走得太远而忘记为什么出发》]]></title>
    <url>%2F2018%2F04%2F21%2F2018-04-21-not-forget-why-go%2F</url>
    <content type="text"><![CDATA[今天所做的一切相加就等于未来 生命需要保持一种激情，激情能让别人感到你是不可阻挡的时候，就会为你的成功让路，一个内心不可屈服的气质是会感动人的，并能够改变很多东西 这不是你要的，不是你喜欢的 有心人即便打杂，也不忘学艺 一个完全不同的结果，一定有一个完全不同的过程，你不改变这个过程就改变不了这个结果 努力不是成功的根本。想成功的人都很努力，但成功的人往往只有一小部分。倘若你努力，但你的观念是错误的，很可能离正确的方向越来越远。所以更加重要的是观念。而认识观念、改变观念完全是由思为防止决定的。 人要有两方面的能力，我们一般来说更注重一种知识的积累，而与知识相比，有一个更需要注意的，那就是思维方法，包括你接受新知识的能力，包括你判断和处理信息的能力，这些应该比知识更重要。 生活的磨难能够成为力量的源泉 人一生要学会经常往回看——为什么呢？我们从小收的教育一直都是站在起点往终点看，上了小学琢磨着上个好中学，上完中学，琢磨着考个好大学再找个好工作。价值观都是单向的，我觉得必须再添一个往回看的坐标。你想啊，曾经那些刻骨铭心、要死要活、当时自认为撑不过去的事情，现在看来也不过尔尔。 提炼归纳，举一反三，哲理性思辨。总结不是交给上级的，也不是交给父母的，也不是拿给大家念的，就是自己给自己总结。 我过着过着突然明白了，“现在”就是小时候想过无数次要为之奋斗的未来啊。所以最现实的做法就是把现在的事情、眼前的事情做好。今天所做的一切相加就等于把未来。 干任何事情都不容易，选择了一种工作，实际上也就选择了一种生活方式。 因为走得太远，我们已经忘记了为什么要出发。 当你过于进入、过于热衷于一个东西时，你就需要去放弃这个东西。你只有出去了才能进来，也只有进来了才能出去。 如果一个人过于热爱某个东西，那么这东西就已经不再是它本身，已经变成了你的一种热爱，强加了你许多个人的东西，而不是事件本身。 《太极》里说，太想练成的人和三心二意的人，都练不成太极。你必须保持一定状态，才能得到一种真传。按照西方的没血表述就是，距离产生美，必须有一定的距离，贴得太近反而什么也看不见。17.大道无术，最重要的时修炼自己，提升自己，而不是学什么与人斗的方法。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>求知</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git基本命令使用（一）]]></title>
    <url>%2F2018%2F04%2F17%2F2018-04-17-git-command%2F</url>
    <content type="text"><![CDATA[1.基本配置 git全局配置文件 命令：git config –global &lt;配置名称&gt;&lt;配置的值&gt; 可使用 ls -al 或者是cat ~/.gitconfig 查看配置文件 2.clone一个仓库 git clone https://github.com/username/仓库名 git init 初始化仓库 3.正常的工作流程git的基本流程如下： 创建或修改文件 使用git add命令添加新创建或修改的文件到本地的缓存区（Index） 使用git commit命令提交到本地代码库 （可选，有的时候并没有可以同步的远端代码库）使用git push命令将本地代码库同步到远端代码库 echo “添加内容”&gt;&gt; 文件名git status 查看当前git仓库的状态git diff –cached 查看缓存区中的那些文件被修改 5.分支与合并 分支 Git的分支可以让你在主线（master分支）之外进行代码提交，同时又不会影响代码库主线。分支的作用体现在多人协作开发中，比如一个团队开发软件，你负责独立的一个功能需要一个月的时间来完成，你就可以创建一个分支，只把该功能的代码提交到这个分支，而其他同事仍然可以继续使用主线开发，你每天的提交不会对他们造成任何影响。当你完成功能后，测试通过再把你的功能分支合并到主线。 git branch 分支名 创建分支 git checkout 分支名 切换到其他分支 git branch -d 只能删除那些已经被当前分支的合并的分支. git branch –D 强制删除某个分支 合并 git reset –hard HEAD^ 撤销合并 快速向前合并还有一种需要特殊对待的情况，在前面没有提到。通常，一个合并会产生一个合并提交(commit), 把两个父分支里的每一行内容都合并进来。但是，如果当前的分支和另一个分支没有内容上的差异，就是说当前分支的每一个提交(commit)都已经存在另一个分支里了，git 就会执行一个“快速向前”(fast forward)操作；git 不创建任何新的提交(commit),只是将当前分支指向合并进来的分支。 6.git 日志 git log 查看日志 git log –stat 日志统计 git log –pretty=oneline 或 git log –pretty=short pretty参数可以使用若干表现格式 你也可用medium,full,fuller,email 或raw。 如果这些格式不完全符合你的需求， 你也可以用–pretty=format参数定义格式。 –graph 选项可以可视化你的提交图(commit graph)，会用ASCII字符来画出一个很漂亮的提交历史(commit history)线日志记录可以按不同的顺序来显示。如果你要指定一个特定的顺序，可以为git log命令添加顺序参数。 按默认情况，提交会按逆时间顺序显示，可以指定–topo-order参数，让提交按拓扑顺序来显示(就是子提交在它们的父提交前显示): $ git log –pretty=format:’%h : %s’ –topo-order –graph也可以使用 –reverse参数来逆向显示所有提交日志 小结 git config：配置相关信息 git clone：复制仓库 git init：初始化仓库 git add：添加更新内容到索引中 git diff：比较内容 git status：获取当前项目状况 git commit：提交 git branch：分支相关 git checkout：切换分支 git merge：合并分支 git reset：恢复版本 git log：查看日志]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>求知</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三十六计，巧藏诗中]]></title>
    <url>%2F2018%2F04%2F13%2F2018-04-13-qiao-ji-36-ji%2F</url>
    <content type="text"><![CDATA[《巧记三十六计诗》 金 玉 檀 公 策,借 以 擒 劫 贼。 鱼 蛇 海 间 笑,羊 虎 桃 桑 隔。 树 暗 走 痴 故,釜 空 苦 远 客。 屋 梁 有 美 尸,击 魏 连 伐 虢。 注：全诗除檀公策三字外,最后两字伐虢代表一计，其余每字均代表三十六计中的一计. 金 玉 檀 公 策 金蝉脱壳 抛砖引玉 借 以 擒 劫 贼 借刀杀人 以逸待劳 擒贼擒王 趁火打劫 关门捉贼 鱼 蛇 海 间 笑 浑水摸鱼 打草惊蛇 瞒天过海 反间计 笑里藏刀 羊 虎 桃 桑 隔 顺手牵羊 调虎离山 李代桃僵 指桑骂槐 隔岸观火 树 暗 走 痴 故 树上开花 暗度陈仓 走为上计 假痴不癫 欲擒故纵 釜 空 苦 远 客 釜底抽薪 空城计 苦肉计 远交近攻 反客为主 屋 梁 有 美 尸 上屋抽梯 偷梁换柱 无中生有 美人计 借尸还魂 击 魏 连 伐虢 声东击西 围魏救赵 连环计 假途伐虢 第一计 瞒天过海【原文】 备周则意怠，常见则不疑。阴在阳之内，不在阳之对，太阳，太阴。 【译文】 自以为军事防备极其周密时，其斗志就容易松懈，麻痹轻敌；平时看惯了的，就不容易引起怀疑， 阴晦的计谋与公开的形式并不互相排斥，相反，它往往深藏在张扬暴露的行为之中。这就是易理中 阴阳交互的为用的原则。 第二计 围魏救赵【原文】 共敌不如分敌，敌阳不如敌阴 【译文】 与其攻打集中的正面强敌，不如迫使敌人分散兵力以后再打，迎击敌人的正面攻势，不如迂回到敌 人虚弱的一方，伺机消灭敌人。 第三计 借刀杀人【原文】 敌已明，友未定，引友杀敌，不自出力，以“损”推演。 【译文】 敌人已经明确，而盟军的态度还不稳定，要诱导盟军去消灭敌人，避免消耗自己力量。 第四计 以逸待劳【原文】 困敌之势，不以战，损刚益柔 【译文】 迫使敌人处于困难的局面，而不是采取直接进攻的方法；刚柔相互转化，这是从损卦中推演出来的计谋。 第五计 趁火打劫【原文】 敌之害大，就势取利，刚决柔也。 【译文】 敌方出现严重危机，就要乘机出兵夺取胜利，这是从卦象上演出来的计谋。 第七计 无中生有【原文】 诳也，非诳也，实其所诳也；少阴，太阴，太阳。 【译文】 用假象去欺骗敌人，但并非是弄假到底，而是要巧妙地由虚变实，利用对方已经产生的错觉，假象就能够掩护真象，按照益卦的原理，就是开始时用小的假象，继而用大的假象，最后突然变成真象。 第八计 暗渡陈仓【原文】 示之以动，利其静而有主，益动而巽。 【译文】 故意暴露自己的佯攻动向，利用敌方在此处固守之际，我则偷偷迂回敌彼处袭击，这就是益卦原理的演用。 第九计 隔岸观火【原文】 阳乖序乱，阴以待逆，暴戾瓷瞧，其势自毙，顺以动豫，豫顺以动。 【译文】 敌方内部矛盾趋于激化和表面化，秩序混乱。这时，我方一定要静静等待敌人发生暴乱，等敌方反目成仇，穷凶极恶，势必自取灭亡，这就豫卦的原理，能够顺应时机而行动，就会得到好的结果。 第十计 笑里藏刀【原文】 信而安之，阴以图之；备而后动，勿使有变。刚中柔外也。 【译文】 使敌人相信我方的“友好诚意“而麻痹松懈，我则借机暗中谋划，积极准备，待机行动，切不要让它发生变化，这就是暗藏杀机，外示和好的谋略。 第十一计 李代桃僵【原文】 势必有损，损阴以益阳。 【译文】 当战局发展必然会有损失时，要舍得局部的损失，以换取全局的胜利。 第十二计 顺手牵羊【原文】 微隙在所必乘；微利在所必得，少阴，少阳。 【译文】 出现微小的漏洞，也必须及时利用：发现微小的利益也要力争获得，变敌方小的疏忽为我方小的胜利。 第十三计 打草惊蛇【原文】 疑以叩实，察而后动；复者，阴以谋也。 【译文】 有怀疑就在侦察确实，待情况完全掌握了再行动，反复侦察，是发现暗藏敌人的条件。 第十四计 借尸还魂【原文】 有用者，不可借，不能用者，求借。借不能用者而用之，匪我求童蒙，童蒙求我。 【译文】 凡有作为的，难以驾驭和控制，不能加以利用，凡没有作为的，往往要依附别人以强立，这就会来求助于我，利用没有作为的并顺势控制它，这不是我受别人支配，而是我支配别人。 第十五计 调虎离山【原文】 待天以困，用人以诱之，往蹇来返。 【译文】 等待自然条件对敌方不利时去围困它，用人为的假象去诱骗它，向前进攻有危险，那就想办法让敌人返过来攻我。 第十六计 欲擒故纵【原文】 逼则反手兵，走则减势，紧随勿迫，累其气力，消其斗志，散而后擒，兵不血刃，需，有孚，光。 【译文】 逼得敌人无路可走，它就会反扑；让它逃跑则可以减弱敌人的气势。追击时，跟踪敌人不要过于逼迫它，以消耗它的体力，瓦解它的斗志，待敌人士气沮丧、溃不成军，再捕捉它，就可以避免流血，按照《易经·需》卦的原理，待敌人心理上完全失败而信服我，就能赢得光明的战争结局。 第十七计 抛砖引玉【原文】 类以诱之，击蒙也。 【译文】 用极类似的东西迷惑敌人，使敌人懵懂上当。 第十八计 擒贼擒王【原文】 摧其坚，夺其魁，以解其体。龙战于野，其道穷也。 【译文】 摧毁敌人的主力，抓住它的首领，就可以瓦解它的整体力量。好比龙出大海到陆地上作战，面临绝境一样。 第十九计 釜底抽薪【原文】 不敌其力，而消其势，兑下乾上之象 【译文】 不能够迎击敌人强大的正面力量，就要消灭敌人强大的力量借以存在或产生的根源，消灭事物借经存在发展的对面，事物本身的正面也就难以存在与发展了。 第二十计 浑水摸鱼【原文】 乘其阴乱，利其弱而无主，随，以向晦人宴息。 【译文】 乘着敌人内部混乱之机，利用它的懵懵没有主见的弱点使它顺从。这是一个自然规律，就像人到晚上一定要入室休息那样自然。 第二十一计 金蝉脱壳【原文】 存其形，定其势；以不疑，敌不动，巽而止蛊。 【译文】 保持原来的形态，完整原来的阵势，友军不怀疑，敌人不敢轻举妄动，隐蔽转移主力，必须先要迷惑敌人。 第二十二计 关门捉贼【原文】 小敌困之。剥，不利有攸往。 【译文】 对于小股敌人可以将他们围困住，剥夺围歼，放走他们是极其有害的。 第二十三计 远交近攻【原文】 形禁势格，利从近取，害以远隔。上火下泽。 【译文】 地理位置受到限制，形势发展受到阻碍，攻取较远的地方就有害；攻取较近的地方就有利，火焰是上窜的，泽水永远是向低洼处流淌的，万呈发展变化全是如此。 第二十四计 假途伐虢【原文】 两大之间，敌胁以从，我假以势。困，有言不信。 【译文】 处于两大敌对势力的第三者，敌方用武力强迫它屈服，我方针对这种形势表示支援它，就会取得它的信任，但处于这种困境的第三者，是不会单纯相信嘴巴所说的。 第二十五计 偷梁换柱【原文】 频更其阵，抽其颈旅，待其自败，而后乘之，曳其轮也。 【译文】 频繁不断地变更敌方的阵势，抽调开它的精锐主力，待它外实内虚，就可以乘机击垮它，拖住车轮，整个车子也就没用了。 第二十六计 指桑骂槐【原文】 小凌小者，警以透之，刚中而立，行险而顺。 【译文】 强者慑服弱者，要用威戒，警告的方法治它。威严适当就心服，甘愿听命，冒死奋战。 第二十七计 假痴不癫【原文】 宁伪作不知不为，不伪作假知妄为。静不露机，云雷屯也。 【译文】 宁愿假装糊涂而不有所为。不自作聪明去轻举妄动，要沉着冷静，深藏不露，如同雷云入冬，屯聚隐没一样。 第二十八计 上屋抽梯【原文】 假之以便，唆之便前，断其援应，陷之死地，遇毒，位不当也。 【译文】 故意显示出有利可图之点，引诱敌人进入绝境，截断它的增援或接应部队使它全部陷入死，遭遇覆灭的大祸，那是由于贪得无厌。 第二九计 树上开花【原文】 借局布势，力小势大。鸿渐于陆，其羽可用为仪也。 【译文】 借用别人的兵力来布置威武的阵势，虽然自己实际弱小但可以显示宏大。高空飞来的鸿雁，用它的羽毛可以装饰显赫的仪表。 第三十计 反客为主【原文】 乘隙插足，扼其主机，渐之进也。 【译文】 乘机会就插手进去，抓住它的主权，这须逐步慢慢来。 第三十一计 美人计【原文】 兵强者，攻其将；将智者，伐其情。将弱兵颓，其势自萎。利用御寇，顺相保也。 【译文】 对实力强大的敌人，主要是进攻它的将帅；对有智谋的将帅，主要是设法瓦解他的斗志，将帅的斗志沦丧，其兵必然情绪颓废，整个三军就会萎靡不振，利用敌方主将的弱点对其分化瓦解，可以转变敌我形势，保全自己。 第三十三计 反间计【原文】 疑中之疑，比之自内，不自失也。 【译文】 在疑局中再设一疑局，并顺势向敌营巧妙安排内应。这样，我军内外配合，即可获胜。 第三十四计 苦肉计【原文】 人自害，受害必真，假真真假，间以得行。童蒙之吉，顺以巽也。 【译文】 任何人都不愿遭到伤害，受到伤害必定令人置疑；我以假作真，并使敌人相信是真而不假时，离间计谋就可以实现。因而，要善于迎合敌营内之同情心理，顺势进行活动。 第三五计 连环计【原文】 将多兵众，不可以敌，使其自累，以杀其势，在师中吉，承天宠也。 【译文】 敌军兵力强大，就不要去硬拼，应当运用计谋使其自相牵制，借以彻底削弱其战斗实力，将帅巧妙指挥，用兵如神，必能获胜无疑。 第三十六计 走为上【原文】 全师避敌，左走无咎，未失常也。 【译文】 全军退却避开强敌，以退为进临机破敌，这样，同正常的兵法并不违背。 注：整理自网络]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>三十六计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Pytho大法好》之一：批量PDF转Word]]></title>
    <url>%2F2018%2F03%2F31%2F2018-03-31-pdf-to-word%2F</url>
    <content type="text"><![CDATA[所需工具 python 3.6.1 pdfminer3k 整体思路 单个文件处理 读取PDF文件 写入Word文件 批量处理 多线程提高效率 代码实现1.读取PDFfrom pdfminer.pdfinterp import PDFResourceManager from pdfminer.pdfinterp import process_pdf from pdfminer.converter import TextConverter from pdfminer.layout import LAParams def read_from_pdf(file_path): with open(file_path, &apos;rb&apos;) as file: resource_manager = PDFResourceManager() return_str = StringIO() lap_params = LAParams() device = TextConverter( resource_manager, return_str, laparams=lap_params) process_pdf(resource_manager, device, file) device.close() content = return_str.getvalue() return_str.close() return content 2.写入Wordfrom docx import Document def save_text_to_word(content, file_path): doc = Document() for line in content.split(&apos;\n&apos;): paragraph = doc.add_paragraph() paragraph.add_run(remove_control_characters(line)) doc.save(file_path) def remove_control_characters(content): mpa = dict.fromkeys(range(32)) return content.translate(mpa) 3.PDF转换为Worddef pdf_to_word(pdf_file_path, word_file_path): content = read_from_pdf(pdf_file_path) save_text_to_word(content, word_file_path) 4.多线程提高效率from concurrent.futures import ProcessPoolExecutor tasks = [] with ProcessPoolExecutor(max_workers=int(config[&apos;max_worker&apos;])) as executor: for file in os.listdir(config[&apos;pdf_folder&apos;]): extension_name = os.path.splitext(file)[1] if extension_name != &apos;.pdf&apos;: continue file_name = os.path.splitext(file)[0] pdf_file = config[&apos;pdf_folder&apos;] + &apos;/&apos; + file word_file = config[&apos;word_folder&apos;] + &apos;/&apos; + file_name + &apos;.docx&apos; print(&apos;正在处理: &apos;, file) result = executor.submit(pdf_to_word, pdf_file, word_file) tasks.append(result) while True: exit_flag = True for task in tasks: if not task.done(): exit_flag = False if exit_flag: print(&apos;完成&apos;) exit(0) 5.完整实现代码 import os from configparser import ConfigParser from io import StringIO from io import open from concurrent.futures import ProcessPoolExecutor from pdfminer.pdfinterp import PDFResourceManager from pdfminer.pdfinterp import process_pdf from pdfminer.converter import TextConverter from pdfminer.layout import LAParams from docx import Document def read_from_pdf(file_path): with open(file_path, &apos;rb&apos;) as file: resource_manager = PDFResourceManager() return_str = StringIO() lap_params = LAParams() device = TextConverter( resource_manager, return_str, laparams=lap_params) process_pdf(resource_manager, device, file) device.close() content = return_str.getvalue() return_str.close() return content def save_text_to_word(content, file_path): doc = Document() for line in content.split(&apos;\n&apos;): paragraph = doc.add_paragraph() paragraph.add_run(remove_control_characters(line)) doc.save(file_path) def remove_control_characters(content): mpa = dict.fromkeys(range(32)) return content.translate(mpa) def pdf_to_word(pdf_file_path, word_file_path): content = read_from_pdf(pdf_file_path) save_text_to_word(content, word_file_path) def main(): config_parser = ConfigParser() config_parser.read(&apos;config.cfg&apos;) config = config_parser[&apos;default&apos;] tasks = [] with ProcessPoolExecutor(max_workers=int(config[&apos;max_worker&apos;])) as executor: for file in os.listdir(config[&apos;pdf_folder&apos;]): extension_name = os.path.splitext(file)[1] if extension_name != &apos;.pdf&apos;: continue file_name = os.path.splitext(file)[0] pdf_file = config[&apos;pdf_folder&apos;] + &apos;/&apos; + file word_file = config[&apos;word_folder&apos;] + &apos;/&apos; + file_name + &apos;.docx&apos; print(&apos;正在处理: &apos;, file) result = executor.submit(pdf_to_word, pdf_file, word_file) tasks.append(result) while True: exit_flag = True for task in tasks: if not task.done(): exit_flag = False if exit_flag: print(&apos;完成&apos;) exit(0) if __name__ == &apos;__main__&apos;: main() 具体使用可参考 GitHub 特别注意 1.部分PDF转换Word不成功是因为缺少字体的原因，需要下载相应的字体包放到相应位置 2.PDF中的图片不能转换 踩了许多坑，十分感谢各位前辈的探索，站在巨人的肩膀上才能看得更远！ 参考资料 1.60行Python代码，实现多线程PDF转Word 2.手把手|20行Python代码教你批量将PDF文件转为Word格式（包教包会） 3.pdfminer3k 使用文档]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据分析之路|面试题整理之常见算法篇]]></title>
    <url>%2F2018%2F03%2F20%2F2018-03-20-data-analyst-interview-algorithm%2F</url>
    <content type="text"><![CDATA[几种常见排序算法及实现1.冒泡排序（Bubble Sort） 相邻两个元素作比较，冒泡排序是稳定的。算法时间复杂度是O(n^2)。 基本思想： 1）第一轮比较，找出最大的元素；第二轮找出次大的元素…… 2）若有N个元素进行排序，一共比较N-1轮，第M轮要进行N-M次比较； 3）代码实现： static void BubbleSort(int[] arr){ for (int times=1,times&lt;=arr.length-1,times++) //比较arr.length-1轮 { for (int i=1,i&lt;=arr.length-times,i++) //每一轮比较arr.length-times次 { if (arr[i-1]&gt;arr[i]){ temp=arr[i-1] arr[i-1]=arr[i] arr[i]=temp } } } } 2.选择排序（Select Sort） 用某一位置的元素依次与其它位置元素相比较。直接选择排序是不稳定的，算法平均时间复杂度是O(n^2)。 基本思想： （1）第一轮比较完毕，出现最小值，第二轮比较完毕，出现次小值…… （2）与冒泡算法一样，若有N个元素进行排序，一共比较N-1轮，第M轮要进行N-M次比较,但是每一轮只交换一次数值 （3）代码实现： static void SelectSort(int[] arr){ for (int times=0,times&lt;=arr.length-1,times++) //以索引为0的元素作为第一个元素，依次与其它元素进行比较。 { int minindex=times for (int i=times+1,i&lt;=arr.length,i++) //i代表索引为i的被比较元素，可以取到arr.length。 { if (arr[i]&lt;arr[minindex]){ minindex=i } } temp=arr[times] arr[times]=arr[minindex] arr[minindex]=temp } } 3.快速排序 快速排序是对冒泡排序的一种改进。 快速排序是不稳定的。最理想情况算法时间复杂度O(nlog2n)，最坏O(n ^2)。 基本思想： （1）首先任意选择一个元素作为初始元素key（一般取第一个元素） （2）从两端开始分别找：从右往左，寻找比key值小的元素交换位置；再从左往右，寻找比key值大的元素交换位置； （3）如此依次循环步骤1.2 (4)代码实现： void quicksort(int left,int right) { if(left&gt;right) return ; else { int i=left; int j=right; T t; T temp=data[left]; while(i!=j) { while(i&lt;j&amp;&amp;data[j]&gt;=temp) j--; //记住必须先动j while(i&lt;j&amp;&amp;data[i]&lt;=temp) i++; if(i!=j) swap(i,j); //原地交换 } swap(left,i); quicksort(left,i-1); quicksort(i+1,right); } } 4.堆排序 堆排序是一种树形选择排序。 堆排序的时间复杂度为O(n*log(n))， 非稳定排序，原地排序(空间复杂度O(1))。 基本思想：分为最大化堆和最小化堆。 第1趟将索引0至n-1处的全部数据建大顶(或小顶)堆，就可以选出这组数据的最大值(或最小值)。将该堆的根节点与这组数据的最后一个节点交换，就使的这组数据中最大(最小)值排在了最后。 第2趟将索引0至n-2处的全部数据建大顶(或小顶)堆，就可以选出这组数据的最大值(或最小值)。将该堆的根节点与这组数据的倒数第二个节点交换，就使的这组数据中最大(最小)值排在了倒数第2位。 … 第k趟将索引0至n-k处的全部数据建大顶(或小顶)堆，就可以选出这组数据的最大值(或最小值)。将该堆的根节点与这组数据的倒数第k个节点交换，就使的这组数据中最大(最小)值排在了倒数第k位。 代码实现 #include&lt;memory.h&gt; #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; void swap(void* x, void* y, size_t sz) { void* t = malloc(sz); memcpy(t, x, sz); memcpy(x, y, sz); memcpy(y, t, sz); free(t); } void makeHeap(void* x, int i, int n, size_t sz, int(*cmp)(const void*, const void*)) { char* y = (char*)x; int l = 2 * i + 1; int r = 2 * i + 2; int m; if (l&lt;n &amp;&amp; (*cmp)(y + l*sz, y + i*sz)&gt;0) m = l; else m = i; if (r&lt;n &amp;&amp; (*cmp)(y + r*sz, y + m*sz)&gt;0) m = r; if (m != i){ swap(y + i*sz, y + m*sz, sz); makeHeap(x, m, n, sz, cmp); } } void buildHeap(void* x, int n, size_t sz, int(*cmp)(const void*, const void*)) { for (int i = n / 2 - 1; i &gt;= 0; i--) makeHeap(x, i, n, sz, cmp); } void heapSort(void* x, int n, size_t sz, int(*cmp)(const void*, const void*)) { buildHeap(x, n, sz, cmp); char* y = (char*)x; for (int i = n - 1; i &gt;= 1; i--){ swap(y, y + i*sz, sz); makeHeap(x, 0, --n, sz, cmp); } } void p(int* x,int n){ for (int k = 0; k &lt; n; k++){ printf(&quot;%d &quot;, x[k]); } printf(&quot;\n&quot;); } int less(const void* a, const void* b){ return *((int*)a) &lt; *((int*)b); } int greater(const void* a, const void* b){ return *((int*)a) *((int*)b); } int main(){ int x[] = { 2, 3, 4, 6, 8, 2, 9, 0 }; // 降序全排列 heapSort(x, 8, sizeof(int), less); p(x, 8); // 升序全排列 heapSort(x, 8, sizeof(int), greater); p(x, 8); // 最大的4个元素，在数组末尾 heapSort(x, 4, sizeof(int), less); p(x, 8); } 5.归并排序 是建立在归并操作上的一种有效的排序算法。 该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。 算法时间复杂度可以达到O(n) 代码实现 void mergearray(int a[], int first, int mid, int last, int temp[]) { int i = first, j = mid + 1; int m = mid, n = last; int k = 0; while (i &lt;= m &amp;&amp; j &lt;= n) { if (a[i] &lt;= a[j]) temp[k++] = a[i++]; else temp[k++] = a[j++]; } while (i &lt;= m) temp[k++] = a[i++]; while (j &lt;= n) temp[k++] = a[j++]; for (i = 0; i &lt; k; i++) a[first + i] = temp[i]; } void mergesort(int a[], int first, int last, int temp[]) { if (first &lt; last) { int mid = (first + last) / 2; mergesort(a, first, mid, temp);//左边有序 mergesort(a, mid + 1, last, temp); //右边有序 mergearray(a, first, mid, last, temp); //再将二个有序数列合并 } } bool MergeSort(int a[], int n) { int *p = new int[n]; if (p == NULL) return false; mergesort(a, 0, n - 1, p); delete[] p; return true; } 参考文章 2017校招数据分析岗笔试/面试知识点 快速排序全面讲解（含复杂度证明）——即将引出八大排序算法 白话经典算法系列之五 归并排序的实现（讲的真好） 堆排序原理及其实现(C++)]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据分析之路|面试题整理之统计学基础]]></title>
    <url>%2F2018%2F03%2F19%2F2018-03-19-data-analyst-interview-statistics%2F</url>
    <content type="text"><![CDATA[1.四分位极差 四分位极差，也称为内距或四分间距，它是上四分位数（QU，即位于75%）与下四分位数（QL，即位于25%）的差。 计算公式为：Qd =QU-QL 四分位差反映了中间50%数据的离散程度，其数值越小，说明中间的数据越集中；其数值越大，说明中间的数据越分散。 2.左右偏分布 左偏态又称负偏态（，以尾部命名，左偏态或者叫负偏态的尾部，主要在左侧；右偏态又称正偏态，同样地，右偏态或者叫正偏态的尾部，则集中在右侧； 如何判断：是以对称轴来说的,如果对称分布,轴在正中,就是正态.轴在图形的左侧(鼓包部分在右侧),就是左偏.相反,轴在整个图形右侧（大包在左侧）,就是右偏。也可以根据尾巴在哪侧就是向哪侧偏判断。 3.p值 P值（P value）就是当原假设为真时所得到的样本观察结果或更极端结果出现的概率。如果P值很小，说明原假设情况的发生的概率很小，而如果出现了，根据小概率原理，我们就有理由拒绝原假设，P值越小，我们拒绝原假设的理由越充分。总之，P值越小，表明结果越显著。但是检验的结果究竟是“显著的”、“中度显著的”还是“高度显著的”需要我们自己根据P值的大小和实际问题来解决。 4.方差分析 用于两个及两个以上样本均数差别的显著性检验，基本思想是：通过分析研究不同来源的变异对总变异的贡献大小，从而确定控制变量对研究结果影响力的大小。 5.主成分分析 是一种降维的思想。通过正交变换将一组可能存在相关性的变量转换为一组线性不相关的变量，转换后的这组变量叫主成分。 6.幸存者偏差 当取得资讯的渠道仅来自于幸存者时（因为死人不会说话），此资讯可能会存在与实际情况不同的偏差。 7. 贝叶斯公式 P(B|A)=P(A|B)\P(B)/P(A) 其中P(A)可以展开为 P(A)=P(A|B1)\P(B1)+P(A|B2)\P(B2)+…+P(A|Bn)\P(Bn) 8. 聚类 聚类之间类的度量是分距离和相似系数来度量的，距离用来度量样品之间的相似性（K-means聚类，系统聚类中的Q型聚类），相似系数用来度量变量之间的相似性（系统聚类中的R型聚类）。 最常用的是K-means聚类，适用于大样本，但需要事先指定分为K个类。处理步骤： 1）从n个数据对象中任意选出k个对象作为初始的聚类中心 2）计算剩余的各个对象到聚类中心的距离，将它划分给最近的簇 3）重新计算每一簇的平均值（中心对象） 4）循环2-3直到每个聚类不再发生变化为止。 系统聚类适用于小样本。 9. 分类有监督就是给的样本都有标签，分类的训练样本必须有标签，所以分类算法都是有监督算法。监督机器学习问题无非就是“minimizeyour error while regularizing your parameters”，也就是在规则化参数的同时最小化误差。最小化误差是为了让我们的模型拟合我们的训练数据，而规则化参数是防止我们的模型过分拟合我们的训练数据，提高泛化能力。 （1）朴素贝叶斯1）基础思想：对于给出的待分类项，求解在此项出现的条件下各个类别出现的概率，哪个最大，就认为此分类项属于哪个类别。 2）优点： 可以和决策树、神经网络分类算法相媲美，能运用于大型数据库中。 方法简单，分类准确率高，速度快，所需估计的参数少，对于缺失数据不敏感。 3）缺点： 假设一个属性对定类的影响独立于其他的属性值，这往往并不成立。（喜欢吃番茄、鸡蛋，却不喜欢吃番茄炒蛋）。 需要知道先验概率。 （2）决策树1）基础思想：决策树是一种简单但广泛使用的分类器，它通过训练数据构建决策树，对未知的数据进行分类。决策树的每个内部节点表示在一个属性上的测试，每个分枝代表该测试的一个输出，而每个叶结点存放着一个类标号。 在决策树算法中，ID3基于**信息增益**作为属性选择的度量，C4.5基于**信息增益比**作为属性选择的度量，CART基于**基尼指数**作为属性选择的度量。 2）优点 ： 不需要任何领域知识或参数假设。 适合高维数据。 简单易于理解。 短时间内处理大量数据，得到可行且效果较好的结果。 3）缺点： 对于各类别样本数量不一致数据，信息增益偏向于那些具有更多数值的特征。 易于过拟合。 忽略属性之间的相关性。 （3）支持向量机1）基础思想：支持向量机把分类问题转化为寻找分类平面的问题，并通过最大化分类边界点距离分类平面的距离来实现分类。 2）优点 ： 可以解决小样本下机器学习的问题。 提高泛化性能。 可以解决**文本分类、文字识别、图像分类**等方面仍受欢迎。 避免神经网络结构选择和局部极小的问题。 3）缺点： 缺失数据敏感。 内存消耗大，难以解释。 （4）K近邻1）基础思想：通过计算每个训练样例到待分类样品的距离，取和待分类样品距离最近的K个训练样例，K个样品中哪个类别的训练样例占多数，则待分类样品就属于哪个类别。 2）优点 ： 适用于样本容量比较大的分类问题 3）缺点： 计算量太大 对于样本量较小的分类问题，会产生误分。 （5）逻辑回归（LR）1）基础思想：回归模型中，y是一个定型变量，比如y=0或1，logistic方法主要应用于研究某些事件发生的概率。 2）优点 ： 速度快，**适合二分类问题。** 简单易于理解，直接看到各个特征的权重。 能容易地更新模型吸收新的数据。 3）缺点： 对数据和场景的适应能力有局限，不如决策树算法适应性那么强 参考文章 2017校招数据分析岗笔试/面试知识点 快速排序全面讲解（含复杂度证明）——即将引出八大排序算法]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>统计学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端开发者手册读书笔记]]></title>
    <url>%2F2017%2F04%2F08%2F2018-04-08-front-end-dev-handbook-notes%2F</url>
    <content type="text"><![CDATA[前端开发者手册前言 1.概述并讨论了前端工程的实践，如何学习以及时间时应该使用什么工具 2.目的：提供学习资料以及开发工具的专业资源，提供研究材料 3.支持web技术(HTML,CSS,DOM以及JavaScript) 1.什么是前端开发者一个前端开发者, 要会使用Web技术(如：HTML,CSS,DOM和JavaScript)设计和开发网站应用. 网站应用, 或运行于 Web平台 之上, 或用于编译非Web平台环境的输入(如：NativeScript). Web浏览器 Chrome Internet Explorer Firefox Safari 无壳浏览器 PhantomJS slimerjs trifleJS Web视图 Cordova (用于本地手机/平板应用) NW.js (即 Node-Webkit, 用于桌面应用) Electron (用于桌面应用) 2.前端的工作职称 前端开发者/工程师 CSS/HTML开发者 前端JavaScript开发人员 前端Web设计师 Web/前端用户界面开发者/工程师 移动/平板前端开发者 前端SEO专家 前端可访问性专家 前端开发运维 前端测试/QA 3.前端开发者常用的网络技术 Hyper Text Markup Language(超文本标记语言, 又称 HTML) Cascading Style Sheets (层叠式样式表, 又称 CSS) Document Object Model (文档对象模型, 又称 DOM) JavaScript Programming Language (JavaScript编程语言, 又称: - ECMAScript 6, ES6, JavaScript 2015) Web API’s (Web应用程序接口, 又称 HTML5 API 或浏览器 API) Hypertext Transfer Protocol (超文本传输协议, 又称 HTTP) Uniform Resource Locator’s (统一资源定位符, 又称 URL) JavaScript Object Notation (JavaScript对象表示, 又称 JSON) Web Content Accessibility Guidelines (网页内容无障碍设计指南, 又称 WCAG) &amp; Accessible Rich Internet Applications (Internet应用程序的无障碍设计, 又称 ARIA) Hyper Text Markup Language(超文本标记语言, 又称 HTML) 超文本标记语言, 通常被称为 HTML, 是被用于创建网页的标准标记语言. Web浏览器能将 HTML 文件渲染成可见的或者可听到的. HTML 随着线索提示, 语义化地描述了网站的结构, 使它成为一种标记语言, 而不是编程语言. - wikipedia.org Cascading Style Sheets (层叠式样式表, 又称 CSS) 层叠式样式表(CSS)是用于描述外观和格式化标记语言编写的文档的样式表语言. 尽管经常被用来改变用 HTML 和 XHTML 编写的网页和用户界面的样式, 但也可用于任何 XML 文档, 包括纯 XML, SVG 和 XUL. 跟 JavaScript 和 HTML 一样, CSS是被大多数网站用于为Web应用程序创建富有吸引力的网页, 用户界面的一种基础技术, 也为许多移动应用程序创建用户界面. - wikipedia.org Document Object Model (文档对象模型, 又称 DOM) 文档对象模型用于代表和对象交互的HTML, XHTML 和 XML 文档, 是一种跨平台和语言无关性的约定. 每一份文档的所有节点被组织成一种树结构, 称为 DOM 树. DOM 对象通过使用对象上的方法被处理和操作, 一个 DOM 对象的公共接口被指定为它的应用程序编程接口(API). - wikipedia.org JavaScript Programming Language (JavaScript编程语言, 又称: ECMAScript 6, ES6, JavaScript 2015) JavaScript 是一种高级的, 动态的, 无类型的和解释型的编程语言, 它已经在 ECMAScript 语言规范中被标准化. 跟 HTML 和 CSS 一样, JavaScript 是 WWW 内容生成的第三种必不可少的技术; 大多数的网会使用Javascript, 并且 Javascript 被所有现在Web浏览器支持. JavaScript 基于原型和函数优先的特点, 使它成为多范型的语言, 支持面向对象的, 命令式的, 和函数式编程风格. JavaScript 能提供 API 来处理文本, 数组, 日期和正则表达式, 但不包括任何 I/O, 如网络, 存储或图形工具, 对这些的依赖取决于宿主环境中嵌入了什么. - wikipedia.org Web API’s (Web应用程序接口, 又称 HTML5 API) 当使用 JavaScript 为Web程序写代码时, 有很多不错的 API 是可以利用的. 下面列举了所有在Web APP 或网站开发中可能会用到的接口. - Mozilla Hypertext Transfer Protocol (超文本传输协议, 又称 HTTP) 超文本传输协议是一个用于分布式, 协作和超媒体信息系统的应用协议, 是 WWW 数据通信的基础. - wikipedia.org Uniform Resource Locator’s (统一资源定位符, 又称 URL) 一个 URL (也称Web地址)是一个资源引用, 指定了资源在计算机网络和检索机制中的位置. 与之类似的概念是 Uniform Resource Identifier(URI), 尽管许多人认为两个术语可以互换使用, 但 URL 是统一资源标识符( URI ).URL 不仅常用于引用一个网页(http), 也可用于文件传输(ftp), 邮件(mailto), 数据库访问(JDBC) 和许多其它应用. - wikipedia.org JavaScript Object Notation (JavaScript对象表示, 又称 JSON) JSON, 有时也称 JavaScript 对象表示, 是一种使用人类可读的文本传输由键值对组成的数据对象的开放格式. 对于异步浏览器/服务器通信(AJAJ), JSON 是主要的数据格式, 很大程度上代替了 XML(AJAX). 尽管最初是从 JavaScript 脚本语言衍生而来, 但是 JSON 是语言无关性的数据格式, 在许多编程语言中, 代码解析和生成 JSON 是很容易的. JSON 的格式最初是由 Douglas Crockford 指定的, 但目前却被描述成两种标准: RFC 7159 和 ECMA-404. ECMA 标准只允许被合法的语法语句描述, 而 RFC 则提供了一些语义化描述和安全考虑. JSON 的官方网络媒体类型 application / JSON, 扩展名是 .json. - wikipedia.org Web Content Accessibility Guidelines (网页内容无障碍设计指南, 又称 WCAG) &amp; Accessible Rich Internet Applications (富Internet应用程序的无障碍设计, 又称 ARIA) 无障碍设计是指产品, 设备, 服务, 或者环境是为残疾人设计的. 无障碍设计的概念意味着与一个人的辅助技术(例如, 电脑屏幕阅读器)相兼容, 确保直接访问(即独立)和”间接访问”. - wikipedia.org 4.前端开发的技术栈对于任何类型的前端开发人员, HTML, CSS, DOM, JavaScript, HTTP/URL 和浏览器利用是基本的技术要求.除此之外还应该掌握下面技术列表中的一个或多个： Content Management System (内容管理系统, 又称 CMS) Node.js Cross-browser testing (跨浏览器测试) Cross-platform testing (跨平台测试) Unit Testing (单元测试) Cross-device testing (跨设备测试) Accessibility / WAI-ARIA (无障碍访问/无障碍富Internet应用程序) Search Engine Optimization (搜索引擎优化, 又称 SEO) Interaction or User Interface design (交互或用户设计) User Experience (用户体验) Usability (可用性/易用性) E-commerce Systems (电子商务系统) Portal Systems (门户系统) Wireframing (框架) CSS layout / Grids (CSS 布局/栅格系统) DOM manipulation (e.g. jQuery) (DOM 操作) Mobile Web Performance (移动Web性能) Load Testing (载荷测试) Performance Testing (性能测试) Progressive Enhancement / Graceful Degradation (渐进增强/优雅降级) Version Control (e.g. GIT) (版本控制) MVC / MVVM / MV (MV 框架) Functional Programming (函数式编程) Data Formats (e.g. JSON, XML) (数据格式) Data API’s (e.g Restful API) (数据API) Web Font Embedding (Web字体嵌入) Scalable Vector Graphics (可伸缩向量图形, 又称 SVG) Regular Expressions (正则表达式) Content Strategy (内容策略) Microdata / Microformats (微数据/微格式) Task Runners, Build Tools, Process Automation Tools (任务管道, 构建工具, 过程自动化工具) Responsive Web Design (响应式设计) Object Oriented Programming (面向对象编程) Application Architecture (应用架构) Modules (模块) Dependency Managers (依赖关系管理) Package Managers (包管理) JavaScript Animation (JavaScript 动画) CSS Animation (CSS 动画) Charts / Graphs (图表/图形) UI widgets (UI工具集) Code Quality Testing (代码质量测试) Code Coverage Testing (代码覆盖测试) Code Complexity Analysis (代码复杂度测试) Integration Testing (集成测试) Command Line / CLI (命令行/命令行界面) Templating Strategies (模板策略) Templating Engines (模板引擎) Single Page Applications (单页应用) XHR Requests (aka AJAX) (XHR 请求, 又称 AJAX) Web/Browser Security (Web/浏览器安全) HTML Semantics (HTML 语义化) Browser Developer Tools (浏览器开发者工具) 5.前端开发能做什么一个前端开发者能在下面的操作系统列(又称: OS)表中之一上手写运行在- Web平台(如: 浏览器)之上的 HTML, CSS 和 JS: Windows Windows Phone OSX iOS Android Ubuntu (or Linux) Chromium 操作系统运行在下面中的一个或者多个设备之上: Desktop computer Laptop / Netbook computer Mobile phone Tablet TV Watch Things (任何你能想到的, 汽车, 冰箱, 灯光, 温控器等) 一般来说, 前端技术通过使用下列运行时场景, 能运行在前面提到的操作系统和设备之上: 运行在 OS 上的Web浏览器(如: Chrome, IE, Safari, Firefox) 运行在 OS 上并由 CLI 驱动的 headless浏览器(如: plantomJS) 一个Web视图/嵌入本机程序的浏览器Tab(当做 iframe)作为运行时环- 境, 作为与本机 API 通信的桥梁. 典型的Web视图应用包括一个由Web技术(HTML, CSS, 和 JS)构建的 UI.(如: Apache Cordova, NW.js, Electron) 一个由Web技术创建的本机程序会在运行时作为与本机 API 通信的桥梁, 被解释执行, UI 将使用本机的UI部分(如: IOS 本机控制)而不是Web技术控制(NativeScript, React Native). 6.开发团队包含角色 视觉设计 UI/交互设计/信息架构师 SEO 策略师 前端开发者 开发-运维工程师 后端开发者 API 开发者 数据库管理员 QA 工程师/测试人员 兵在精而不在多，与其无所不能，不如专攻一点]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>求知</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何让自己做正确的事情？]]></title>
    <url>%2F2014%2F03%2F24%2F2014-03-24-how-to-do-right-thing%2F</url>
    <content type="text"><![CDATA[真实的自己日常生活中，经常遇到这样的事情：考试临近了，你需要将一本专业书看完，为了不分心，你早早地来到了图书馆，挑了一个好位置坐下，你认真看了两页书，突然觉得有点热，于是出去走走，你走到图书馆的落地窗前看看夜景，觉得夜景好美，好久没有看过如此的夜景了，回头看看正在埋头学习的人们，心想自己又是里面勤奋的一员，不禁喜从中来，心血来潮地掏出了手机，拍下了这一幕，发上了微博和朋友圈。 你重新回到了座位上，又满怀成就感地看一阵书，看了一会，觉得自己想去去洗手间，于是你又踱步出去，走出去的时候还不忘看看隔壁的同学，想着自己如果天天都认真看书的话，这样的生活该是如何的充实啊。 去完洗手间，你突然发现图书馆的新书架上多了好多新书，于是你凑了过去，最近上架的新书还挺多的嘛，于是你从书架的这一边看到了另一边，转了一圈，发现这些新书都没有什么好看的，还不如回去看书呢。 你回到了座位上，正准备认真看书，突然手机震了，你拿出手机，原来是微博上有人评论了：哇，好勤奋耶。于是你心怀欢喜地回复：为了应付考试没有办法了云云。回复完微博，突然想起今天没有刷微博呢，才不想错过今天最新的时政和八卦呢，于是，你顺便刷了一下微博，看看大V看看公知看看朋友晒食物，又顺便评论一下，刷完微博，突然想起朋友圈还没有看，打开微信一看，果然又多了几个红点，心想着，自己还是挺受欢迎的嘛，于是又不亦乐乎地在回朋友圈，搞完朋友圈，你又顺便将知乎豆瓣果壳网易新闻刷了一遍。 终于，你将手机的App都刷了，再也没有更新提醒，感觉这个世界都平静下来了，你可以专心地看书了，你先抬抬头，闭闭眼，想恢复一下状态，一下子脑中又浮现了最近追的美剧，一睁开眼睛，发现自己在发呆了，这下，你才下意识地看看表，嚓，原来已经过去了两个小时！我才看了两页书。 是吧，这样的场景是不是很熟悉？是不是有时候留下来一大段的学习时间都被自己分解得支离破碎，然后自己都不知道自己在干嘛？是不是有时候工作中遇到难以解决的事情自己都喜欢放一放，心想着留到有时间才慢慢来整理？ 你是不是觉得有时候你在逃离着什么？你是不是有时候觉得你在回避着什么？你是不是甚至觉得你是一个拖延症重度患者还迟迟不愿改？ 你明明知道这件事情是正确的，但你却为什么不去做？明明知道自己做的是错的，自己为什么还要找各种根本不成立的理由来说服自己？这些道理你都明白，但是你怎么就做不到呢？ 或许你曾经思考过这些问题，但是想这些好像又无聊又累。算吧，在我身上这些只是特例而已啦，下次不会啦。 其实，这不是一种特例，很多次你试图用理性来说服，但却都被自己的情绪打败，做出了错误的判断和决策，事后你也后悔不已，试图改变。 这到底是为什么？ 大脑的斗争我们必须知道我们的决定都是由大脑控制的，我们的大脑里面有新旧皮层，这些皮层是由人的大脑经过漫长的进化得来的。旧皮层是从我们远古时期形成的，适应于以采集狩猎为主的原始社会，我们姑且称这旧皮层所形成的思维为原始认知模块，新皮层是在相对较近的进化年代出现的，经历了现代的工业时代和现在的信息时代，我们姑且称新皮层所形成的思维为高级认知模块。 高级认知模块吸收了古今的文明，适应于现代社会，具有强大计划能力和认知能力，面对各种的问题，能够理性判断并做出正确的选择。 我们通常所说纠结的状态，就是高级认知模块在和原始认知模块在面对同一个问题沟通的过程。在纠结的状态中，你也许会发现，当你在看书和玩游戏中选择，你还是倾向于玩游戏；当你在工作和上网中选择，你还是倾向于先上网；你明知道自己想减肥，但是面对食物还是告诉自己，先吃饱再减肥。 为什么高级认知模块在与原始认知模块在斗争的时候，高级认知模块反而会输掉呢？ 我们原始认知模块早在远古的远古就已经存在，并已经为物种的繁衍做出了卓越的贡献，原始认知模块虽然只对事件进行很简单的判断和条件反射，但是它是对物种的持续存在最重要的因素。对于食物、性、自然环境中的危险、社会交互行为、道德和情绪等等，原始认知模块进化的年代要比高级认知模块久远得多。它们进化年代要比理性大脑要久远得多，它们就像是漫长岁月中跟随着生物一路进化走过来的老功臣，拥有强大的权力和力量，却没有意识到世界已经在最近的500年发生了迅速和巨大的变革。这种变化对于动辄几十上百万年的漫漫进化路来说只是恍然一瞬，然而就是在这一瞬间，这个世界就完全不一样了。可老功臣还没有来得及退休，还在掌握着我们的大脑，引导着我们做出各种跟不上时代的决策。 说到这里，大家可能都已经明白，其实我们所有决策和选择中的困扰就是老功臣不断在否定新进化势力的决定。老功臣就是我们的天性，我们对于很对事情的决策判断都刻画在天性里面；然而同样也正是这些天性，在很多时候会让我们陷入困境。 世界上最痛苦的事情不是和别人作斗争，而是和自己作斗争。 思维的出口既然如此，我们要让自己做正确的事情，该如何做？ 《暗时间》中，刘未鹏将原始认知模块比作是肖申克监狱，用四篇《逃出你的肖申克》来解决这个问题。 《把时间当作朋友》中，李笑来专门用一个篇章《开启你的心智》来教我们不要再让自己成为自己的（原始）大脑的奴隶，翻身做主人，运用心智获得解放。 一、记录痛苦。原始大脑害怕痛苦，喜欢遗忘痛苦，这是原始认知模块的保护机制：错误的选择和失败的记忆会渐渐退却，这是引导人类更好繁衍生长的重要功能。但是，这种机制往往会导致人重复犯错，解决办法之一就是卧薪尝胆，将自己失败原因写下来，总结经验教训，同一个错误不要犯第二次，定期回顾，不断提醒自己。 二、控制天性。承认「希望自己的欲望马上获得满足」是自己的天性就好，平静正确地认识自己的天性是改变天性的第一步。控制天性的方法是：仔细审视自己在哪方面的天性比较强烈，拿出纸和笔，罗列出来，选出自己认为自己最弱、最需要改变的天性，写在随时可以看到的地方，不断提醒自己。 三、推迟满足感。培养自己的耐心，知道自己的目的，将这些耐心用来承受打击和挫折，轻松坦然地面对自己所做下的事情，知道在各个阶段做什么，有计划地安排，控制住自己大脑，去思考，去体会，去做，获得自由的感觉。 四、知识的力量。以上的三个方法，都似乎有一种在和自己斗争，或者做苦行僧的感觉，过程是非常痛苦的，需要有比较强的意志力，只有少数人能够做到。但是，如果我们能够理解到原始认知模块的缺陷和心理弱点，我们反而可以利用这些，来说服自己做正确的事情。例如我们对于高脂肪高热量的热爱和对于减肥的困扰，可以这样理解，在先祖生存的贫瘠环境中，脂肪和热量是稀缺的，因此需要吃多一些存储起来，防止下次不可预测的饥饿到来；而当你进一步意识到自己无法自制的原因是因为你大脑的原始认知模块仍在天真地认为你处在石器时代的时候，你就会觉得任由原始认知模块这个老家伙控制自己是一件极其愚蠢的行为，你的情绪让大脑自然就不希望自己是愚蠢的；进而，认识到以上的这些知识，认识到大脑的局限性，并最终摆脱它的错误驱使，则让人在情绪上感到聪明和愉悦。这样，我们就可以利用以上学到的知识来做正确的事情了。]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>暗时间</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人知识管理的方法]]></title>
    <url>%2F2014%2F03%2F04%2F2014-03-04-personal-know%2F</url>
    <content type="text"><![CDATA[前言知识管理是一个长期养成的过程，不能一蹴而就，有足够的耐心，自然就会有好成果。 为什么要学习知识管理？ 为什么要进行个人知识管理？ 德鲁克说过，没有人为你负责，除了你自己，而你唯一的资本就是知识。在这里我还需要补充一句就是，你唯一的能力就是应用知识创造价值的能力。PKM的最终目标仍然是提升自我的核心竞争力，体现知识创造价值，因此就需要再次强调了不能脱离了某个场景或领域来单独的谈个人知识管理，否则就失去了目标和方向。在我们平时的问题管理，工作，技术研究，学习，时间管理等各个方面都无处不体现知识管理的影子。 知识管理是什么？ 个人知识管理（Personal Knowledge Management）的概念一般指个人通过工具建立知识体系并不断完善，进行知识的收集、消化吸收和创新的过程。 个人知识管理(PKM)-是将知识管理思想应用到个人，形成经验和方法论，为个人创造最大的价值。 PKM与PIM的关系PIM(Personal Information Management)与PKM（Personal Knowledge Management）的区别在于信息与知识。信息与知识是两个不同的概念，信息是未经过处理的输入，它们会主动或者被动地进入自己的视野，一天到晚我们接受到无数的信息，例如电视播的新闻，手机收到短信，邮箱收到的邮件。而知识就是提炼信息之后的结果，它是信息的精华部分，是经过归纳总结得来的。 个人知识管理，又名PKM（Personal Knowledge Management）, 是一种个人收集，验证，存储，搜索，提取，分享知识的过程。PKM有一个相对应的概念叫做PIM（Personal Information Management），这两个概念是完全不一样的，区别如下有两点： 从对象而言，PKM面向的是知识工作者，而PIM面向非知识工作者，知识工作，即有创新需求的工作。 从过程而言，PIM只采用了个人知识管理过程中收集，存储，搜索的过程。可以这样说，PIM只是PKM的子集。很多人使用知识管理软件很长时间，却只是停留在PIM的阶段。知识管理软件就像是一个收纳箱一样，收纳了他们收集的所有信息。而这些知识并没有像化学药剂一样产生连锁反应，所以其对收集者带来的帮助也不是特别明显了。 个人知识的管理流程管理流程主要分为以下四个过程： 1、收集（保存、记录）知识； 2、吸收（优化，萃取）知识； 3、实践操作、应用知识、创造价值； 4、分享知识、研究探讨。 对于个人知识管理仍然涉及到很多方面的内容，而我理解的知识管理的层次主要分为三个方面的内容，其一是从资料收集开始形成个人知识库，第二是根据自我的目标形成知识地图，其三是从知识到技能到方法论和模式不断的进行转换和升华。 收集（保存、记录）知识工具篇工欲善其事必先利其器。 RSS之鲜果阅读器RSS是我个人收集信息来源最多的地方。Google Reader关闭之后，尝试过多种的阅读器，最后选择鲜果阅读器。优点:快、稳定；缺点：更新极其慢。现在专心做RSS阅读器的企业不多了。 RSS源或者高价值博客推荐，选择原则：（1）新文章好；（2）旧文章也好； 看好博客是一种享受。你可以感觉到他们在默默地写但不知道谁在看，那种感觉是多么的平静而优雅。 1、孤岛客 2、左岸读书 3、南桥的博客 4、白板报 5、萧秋水 6、学而时嘻之 7、阳志平的网志 8、卢昌海个人主页 9、Swordi Media Lab 10、我在中国论坛 11、乱象、印迹 12、人人都是产品经理 13、木易人的博客 14、MRTOYY’S BLOG 15、一桌一椅一世界 16、楼群中的飞行 17、海德沙龙 18、人月神话 网页 1、简书 2、知乎和知乎专栏 3、豆瓣读书 4、十五言 5、腾讯大家 6、传送门 网页知识收集工具 1、Chrome浏览器：PKM最好工具就是Evernote加「印象笔记·剪藏」和「印象笔记·悦读」插件。虽然剪藏进步不少，但是用剪藏收集的文章到手机端Evernote的效果还是比较差，字体偏小，阅读体验不佳。如果是剪辑图片，建议采用剪藏，如果是全文剪辑的话，建议采用悦读浏览，再进行剪辑。另外，Chrome的同步书签是Chrome的特色功能，可以在手机同步，也可以云同步，我在Chrome书签中就建立了一个「Cloud」书签，专门用来临时书签。 2、手机端的Chrome用于浏览信息，大多是查询信息，Read it later的软件用的比较少，Read it later的东西我将它全部推送至Evernote了。 知识储存工具印象笔记加有道云笔记 这个搭配是基于手机端的，原因很简单：我不能在手机上装两个印象笔记，同时我不希望所有信息都在印象笔记中。所以，我采取了双线操作：如果要看文章，直接看印象笔记，如果需要记录思考，开有道云笔记。 参考文刀汉三的方法：把文章保存到「00@Inbox」笔记本，然后再进行提炼和总结，最后再分类到具体的笔记本中，我认为这才是行之有效的学习过程。 不知道说得对不对，文刀汉三的方法是参考GTD的任务流入流出思路。 我的印象笔记分类 腾讯微云腾讯出品，在PC和手机都有有相应的软件，上传速度还是挺快的，容量有10T。我已经将常用的文件、软件和自己所有的图片上传到微云了 自己用过国内的网盘还是挺多的，我就逐一说一下吧。 华为网盘，之前使用的网盘。放弃它是因为登录网页端下载文件的时候十分麻烦，使用Chrome浏览器还要下插件，而且还有一堆的广告，微云一出，马上放弃了。 百度云，百度云上面的资源相当丰富，依托百度的服务器，上传和下载的速度还是相当快的。 115，金山，360云盘之类的，我比较担心数据的安全，没有试用过。 Dropbox，Dropbox的安全性是没得说的，对数据安全比较敏感的话建议选用。如果外出或者出差需要取个文件，但是网络又不给力的话，那还是需要衡量一下。出于各种的原因，我选择国内网盘是妥协的结果。 微信公众账号 1、槽边往事（我一直关注他，从博客，微博一直到微信公众号） 2、小道消息 by Fenng（加了他的私人账号，他在朋友圈内的发言大多是纯文字，有吐槽，有调查，更新频率很高，可以看到他对生活事情的思考） 3、萧秋水（虽然博客更新的频率慢了，但是她在公众号更新的文章是唯一的，需要向她学习） 4、MacTalk By 池建强（不得不说，我用Markdown也多得他，最近通过精进学堂获得了他的《人生元编程》，初步接触了Markdown和Mac大有裨益） 5、改变自己（人总要有些改变，总要有些励志，总要有些成长） 6、大象公会（普及常识，原创内容，值得关注） 7、连岳（我最喜欢的专栏作家，我买了《我爱问连岳》1234） 8、cnfeat（这是我自己的公众账号，用作练习写千字文） 微信文章收藏工具我的印象笔记（微信服务号） 这是采集微信好文章的重要方式，关注并绑定之后，在微信朋友圈看到好文章点击分享到我的印象笔记，这篇文章就可以同步到Evernote上，微信上的公众账号就像是阅读器上的RSS源，非常好用。 移动App 1、知乎 2、知乎日报（主要是看如何正确地吐槽） 3、印象笔记（这就是我为什么没有装Read it later之类软件的原因） 4、有道笔记（印象笔记用于输入信息，有道笔记用于输出信息，这样就有效地区分信息流） 5、Quora（学习英文的好地方） 6、豆瓣阅读（在上面看免费书籍都够了，例如知乎周刊，简书周刊，豆瓣阅读排版是没得说的） 7、多看（阅读软件备选） 8、锤子便签（可以发长微博，阅读体验非常好，iPhone端推荐用Zine） 9、Doit.im（严格按照GTD流程制作的软件，个人觉得比any.do好） 10、腾讯微云（移动大硬盘） 11、单词锁屏（开锁前看看单词） 社交网络 1、微信：几乎取代QQ 2、微博：重新挖掘微博的价值，鉴于新浪上信息源还是挺多的，提供一个保存新浪微博内容到印象笔记的用法，在微博上关注「我的印象笔记」绑定账户，在评论下@我的印象笔记，自己的微博，别人的微博，转发或评论都可以保存到印象笔记自动生成「新浪微博」的tag中去。 3、知乎和知乎专栏：我的知乎专栏：千字文 4、简书：真心希望简书做出一个软件，而不是在线发布平台，还是喜欢离线写 5、豆瓣 6、Quora 书籍书籍部分属于非网络的信息采集途径，推荐在豆瓣读书获取优质豆列推荐来读书，豆瓣上8分以上的书还是属于好书的。读完书之后可以通过思维导图或者读后感的形式整理。 或者可以参照刘未鹏的这篇文章《一直以来伴随我的一些学习习惯(三)：阅读方法》 在这里顺便推荐一下刘未鹏的博客「MIND HACKS 」，更新慢，但是每篇都是干货！或者直接买他博客集出的书《暗时间》 交谈或者培训课程与君一席话，胜读十年书。三人行必有我师。保持有一颗求知的心，身边的师傅、朋友、同学，甚至领导都会给到很好的意见和启发。可以将这些记录下来，不断实践。 吸收（优化，萃取）知识这个过程就比较复杂，你看看我写过这这几篇文章就知道什么是吸收知识的过程。 收集整理是一个很重要的过程，鉴定知识的正确性和有效性的能力并不是每个人都拥有的，不过，我们很幸运，这种能力是可以培养的。学习CriticalThinking相关知识可以帮助我们加深对这方面的理解。 如同把书读薄一样，学习和整合资料的过程就是要进一步把资料读少，在读和学的过程中不断的剔除掉垃圾和无价值的资料。资料的分类管理是第一步，但远远不够，做第二次过滤需要对每个资料都进行泛读，通过泛读对资料的价值和优先级进行排序，以确定后期学习的计划和学习的重点。 [1]如何搭建一个独立博客——简明Github Pages与Hexo教程 [2]何为高段位的学习者？——《怎样成为高段位的学习者？》的求知索引之一 [3]什么是知识的结构与解码？——《怎样成为高段位的学习者？》的求知索引之二 [4]为什么练习在学习中那么重要？ ——《怎样成为高段位的学习者？》的求知索引之三 [5]怎么打通知识的任督二脉？ ——《怎样成为高段位的学习者？》的求知索引（完）(javascript:void(0)) [6]我学习思维导图的过程（1） [7]我学习思维导图的过程（2） [8]我学习思维导图的过程（3） [9]我学习思维导图的过程（4） 实践操作、应用知识、创造价值 任何知识管理工具和系统，如果走不到第三个层次则始终是停留在使用阶段，而无法真正过渡到创造阶段，（那么就达不到我们学习的目的）。 我们进行的知识管理应该站在了前人的肩膀上面，后面要做的就是通过自我知识的学习形成相关的经验，大家通过知识平台的讨论和固化，将我们的经验积累为相关的方法论和模式。 方法论会告诉我们遇到河流你需要通过桥过去，搭桥过去，或者说学习游泳技能过去；遇到山你可以爬过去，打个隧道过去，也可以绕过去。 你可以根据你自己的情况选择相关的方法。所以有了这些大家共同积累下来的方法论和模式，再给你一张地图的时候，你不一定安装常规的学习路线走，你可以在方法论和模式的指导下创造出更多的行走路线，你要做的是根据自己的技能特点和面临的场景，选择最适合自己的学习路线。 写作工具篇 MarkdownPad强烈建议使用Markdown语法进行写作，这是一种能让你减轻排版压力，更专注于写作的轻量级标记语言。 Word、Pages 实际上是字处理软件，这些东西的真正目的在于排版而不在于写作。 Everything文件搜索最好的工具，没有之一 ALTRun国产神级快速启动软件，最好用。 纸笔电脑不在身边的时候就要考虑使用纸笔来辅助。 辅助工具 纸笔 思维导图：初学者可以先尝试使用Xmind，不过我还是喜欢手绘。学习思维导图的可以根据以上的《我学习思维导图的过程》一步一步来。 图片外链，因为Markdown是纯文本输入，必须得有一个稳定的图片外链库。推荐比较靠谱的云存储商，我自己在使用七牛云存储，标准用户，免费，需绑定手机。其次是Yupoo，有100m的免费空间。 观察和应用生活 资料-&gt;知识-&gt;技能-&gt;经验，资料要真正可用必须经过一个学习，抽取提炼和整合的过程。如果简单的认为任何别人的资料自己捡来就可以用则是很盲目的。别人提供的资料仅仅是自我学习，总结和归纳的基础，而不是一个直接应用的基础。 这些要靠积累，参考以下我的文章或者可以给到你启发。 [1]加油站的产品观 [2]写一份老板满意的申请 [3]基础只靠一样东西：练——浅谈学习和写作 [4]如何在Quora上学英语 [5]餐饮服务应该这么做（1） [6]餐饮服务应该这么做（2） [7]餐饮服务应该这么做（3） 分享知识、研究探讨分享平台 1、公众账号； 2、简书（重要的是支持Markdown）； 3、知乎专栏； 4、十五言； 5、博客（独立博客）； 6、PDF，最好的文件发布格式； 7、微博 8、朋友圈 分享知识的必要性 如果不懂得分享，知识永远只是你的，如果知识不能流动，就像地上的一滩水，面积永远只有这么大。流动的知识却能被注入更多的活力，也许您是某一个方面的专家，也请不要小瞧“砖家”的威力，他们也许会提出一个问题，吓你一大跳！ 分享知识不只是分享，也完善了你的知识。 完善知识结构 如何去学习？这里我想强调的就是先找到你最关心的专业和方向，根据这些专业方向完善自我的知识结构和知识地图，然后在日后的工作和实践过程中不断去对知识结构的细节进行完善。如果把知识用一颗大树来比喻的话，就是确定了自我的目标和方向后先不要在某一个知识点上钻的太深，而是要尽快的完善整个树的树干，树干完了知识结构就出来的。后续的树叶不要想着一下全部搞清楚，等到具体实践和应用的时候再逐步完善。 应用知识说到底，知识管理就是用于创造价值，并不是所有知识都能够创造价值，但是知识不做管理，想用的时候就找不出来，那学来有何用。 做好了知识管理，可以给自己带如下的好处： 个人品牌最大受益者 内在品德修养比外在形象更重要 持续学习和终身学习 提高个人核心竞争力 个人知识管理帮助你作好归纳和总结，但还无法上升到一个更高的高度．当有了这些量的积累后才谈得上质变，质变的结果就是我们经常需要的创新思维和系统观．你需要站在巨人的肩膀上，这样才能够走得更远，看得更高.Google不是让你不思考，而是让你从重复的无价值的活动中解脱出来．真正将思维用在有价值的事情上． 总结最后，愿大家都能够利用知识管理过一个充实而有趣的人生。 参考资料[1]文刀汉三：我的个人信息管理 [2]月光博客：我的个人知识管理工具软件 [3]人月神话：个人知识管理-随记 [4]人月神话：主题阅读-个人知识管理 [5]知乎讨论：个人知识管理最常见的误区有哪些？ [6]长云博客：PKM个人知识库结构图 [7]Albert：个人知识管理的误区 [8]人月神话：个人知识管理－再谈下知识结构 [9]长云：个人知识体系和价值体系 [10]人员神话：我理解的知识管理层次 [11]人员神话：从资料收集下载谈起(上) [12]人员神话：从资料收集下载谈起(下)－知识和技能 [13]人月神话：读田志刚的个人知识管理心得集 [14]人月神话：知识的深度和广度-沙堆模型 [15]人月神话：个人学习和知识管理之六忌 [16]人月神话：个人知识管理点滴 [17]人月神话：高瞻远瞩和好高骛远 [18]人月神话：从和谐生产到知识创造：此文提出知识的粒度的概念 [19]人月神话：拿来主义和植物人 [20]人月神话：个人知识管理感悟和ppt下载 [21]人月神话：个人自我管理-培训课件内容 [22]人月神话：个人知识管理-课后总结]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>学习方法</tag>
        <tag>求知</tag>
      </tags>
  </entry>
</search>
